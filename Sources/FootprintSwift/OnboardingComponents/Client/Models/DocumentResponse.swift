//
// DocumentResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Response for a identity document request. Errors are non-optional if the identity vendor.  Requires additional images be collected. */
public struct DocumentResponse: Codable, JSONEncodable, Hashable {

    public enum Errors: String, Codable, CaseIterable {
        case imageTooSmall = "image_too_small"
        case documentMissingFourCorners = "document_missing_four_corners"
        case documentTooSmall = "document_too_small"
        case documentBorderTooSmall = "document_border_too_small"
        case faceImageNotDetected = "face_image_not_detected"
        case barcodeNotDetected = "barcode_not_detected"
        case invalidJpeg = "invalid_jpeg"
        case documentIsSkewed = "document_is_skewed"
        case internalError = "internal_error"
        case imageError = "image_error"
        case docTypeMismatch = "doc_type_mismatch"
        case unknownDocumentType = "unknown_document_type"
        case unsupportedDocumentType = "unsupported_document_type"
        case wrongDocumentSide = "wrong_document_side"
        case wrongOneSidedDocument = "wrong_one_sided_document"
        case documentNotReadable = "document_not_readable"
        case unableToAlignDocument = "unable_to_align_document"
        case idTypeNotAcceptable = "id_type_not_acceptable"
        case selfieFaceNotFound = "selfie_face_not_found"
        case faceNotFound = "face_not_found"
        case selfieLowConfidence = "selfie_low_confidence"
        case selfieTooDark = "selfie_too_dark"
        case selfieGlare = "selfie_glare"
        case selfieHasLenses = "selfie_has_lenses"
        case selfieHasFaceMask = "selfie_has_face_mask"
        case selfieBlurry = "selfie_blurry"
        case selfieImageSizeUnsupported = "selfie_image_size_unsupported"
        case selfieImageOrientationIncorrect = "selfie_image_orientation_incorrect"
        case selfieBadImageCompression = "selfie_bad_image_compression"
        case driversLicensePermitNotAllowed = "drivers_license_permit_not_allowed"
        case unknownCountryCode = "unknown_country_code"
        case countryCodeMismatch = "country_code_mismatch"
        case unknownError = "unknown_error"
        case documentGlare = "document_glare"
        case documentSharpness = "document_sharpness"
        case militaryIdNotAllowed = "military_id_not_allowed"
    }
    public enum NextSideToCollect: String, Codable, CaseIterable {
        case front = "front"
        case back = "back"
        case selfie = "selfie"
    }
    public var errors: [Errors]
    public var isRetryLimitExceeded: Bool
    public var nextSideToCollect: NextSideToCollect?

    public init(errors: [Errors], isRetryLimitExceeded: Bool, nextSideToCollect: NextSideToCollect? = nil) {
        self.errors = errors
        self.isRetryLimitExceeded = isRetryLimitExceeded
        self.nextSideToCollect = nextSideToCollect
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case errors
        case isRetryLimitExceeded = "is_retry_limit_exceeded"
        case nextSideToCollect = "next_side_to_collect"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(errors, forKey: .errors)
        try container.encode(isRetryLimitExceeded, forKey: .isRetryLimitExceeded)
        try container.encodeIfPresent(nextSideToCollect, forKey: .nextSideToCollect)
    }
}

