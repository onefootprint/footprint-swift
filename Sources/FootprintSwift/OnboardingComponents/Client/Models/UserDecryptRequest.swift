//
// UserDecryptRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct UserDecryptRequest: Codable, JSONEncodable, Hashable {

    public enum Transforms: String, Codable, CaseIterable {
        case toLowercase = "to_lowercase"
        case toUppercase = "to_uppercase"
        case toAscii = "to_ascii"
        case prefixLessThanNGreaterThan = "prefix(<n>)"
        case suffixLessThanNGreaterThan = "suffix(<n>)"
        case replaceLessThanFromGreaterThanCommaLessThanToGreaterThan = "replace(<from>,<to>)"
        case dateFormatLessThanFromFormatGreaterThanCommaLessThanToFormatGreaterThan = "date_format(<from_format>,<to_format>)"
        case hmacSha256LessThanKeyGreaterThan = "hmac_sha256(<key>)"
        case encryptLessThanAlgorithmGreaterThanCommaLessThanPublicKeyGreaterThan = "encrypt(<algorithm>,<public_key>)"
    }
    /** List of data identifiers to decrypt. For example, `id.first_name`, `id.ssn4`,  `custom.bank_account` */
    public var fields: [VaultDI]?
    /** Reason for the data decryption. This will be logged */
    public var reason: String?
    /** A list of filter and transform functions to apply to each decrypted datum.  Omit or leave empty to apply no transforms.  Can find more information on allowed transform functions on our docs */
    public var transforms: [Transforms]?
    /** When provided, decrypts the user's data as it existed at the provided timestamp.  Provided as an ISO 8601 timestamp string, like `2024-01-01T12:00:00Z`. */
    public var versionAt: Date?

    public init(fields: [VaultDI]? = nil, reason: String? = nil, transforms: [Transforms]? = nil, versionAt: Date? = nil) {
        self.fields = fields
        self.reason = reason
        self.transforms = transforms
        self.versionAt = versionAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case fields
        case reason
        case transforms
        case versionAt = "version_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(fields, forKey: .fields)
        try container.encodeIfPresent(reason, forKey: .reason)
        try container.encodeIfPresent(transforms, forKey: .transforms)
        try container.encodeIfPresent(versionAt, forKey: .versionAt)
    }
}

